package br.lassal.dbvcs.tatubola.relationaldb.serializer;

import br.lassal.dbvcs.tatubola.fs.InMemoryTestDBModelFS;
import br.lassal.dbvcs.tatubola.relationaldb.model.*;
import br.lassal.dbvcs.tatubola.relationaldb.repository.OracleRepository;
import br.lassal.dbvcs.tatubola.text.SqlNormalizer;
import com.github.vertical_blank.sqlformatter.SqlFormatter;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static org.junit.Assert.*;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class RoutineSerializerTest extends BaseSerializerTest{

    /**
     * Test if the RoutineSerializer is able to
     *  - assemble routines from separated parts: routine definitions + routine parameters
     *  - tidy up the fields and sort them in the proper order
     *  - serialize its content to DBModelFS
     *
     * @throws Exception
     */
    @Test
    public void testRoutineSerialization() throws Exception {
        String env = "DEV";
        String schema = "AAA";
        InMemoryTestDBModelFS dbModelFS = this.createNewDBModelFS();
        SqlNormalizer sqlNormalizer = SqlNormalizer.getInstance(this.repository);

        RoutineSerializer serializer = new RoutineSerializer(this.repository, dbModelFS, schema, env);

        List<Routine> sourceRoutines = new ArrayList<>();
        sourceRoutines.add(this.createProcedure(schema, "RoutineAA", 1));
        sourceRoutines.add(this.createFunction(schema, "FunctionBB", 2));
        sourceRoutines.add(this.createProcedure(schema, "RoutineCC", 3));


        when(this.repository.loadRoutineDefinition(schema)).thenReturn(this.extractRoutineDefinitionOnly(sourceRoutines));
        when(this.repository.loadRoutineParameters(schema)).thenReturn(this.extractRoutinesParameters(sourceRoutines));

        serializer.serialize();

        for(Routine originalRoutine: sourceRoutines){
            InMemoryTestDBModelFS.SerializationInfo serializationInfo = dbModelFS.getSerializationInfo(originalRoutine);
            Routine serializedRoutine = (Routine) serializationInfo.getDBObject();

            //organize the same formatting for the source definition before check equality
            originalRoutine.setRoutineDefinition(sqlNormalizer.formatSql(originalRoutine.getRoutineDefinition()));

            assertEquals(originalRoutine, serializedRoutine);

            int previousParamOrder = -1;
            for(RoutineParameter param : serializedRoutine.getParameters()){
                assertTrue(param.getOrdinalPosition() > previousParamOrder);
                previousParamOrder = param.getOrdinalPosition();
            }
        }

        verify(this.repository, times(1)).loadRoutineDefinition(schema);
        verify(this.repository, times(1)).loadRoutineParameters(schema);

        assertEquals(sourceRoutines.size(), dbModelFS.getNumberSerializedObjects());
    }

    /**
     * Test if the output generated by the IndexSerializer can be deserialized and it
     * has the same properties than the serialized version
     *
     * @throws Exception
     */
    @Test
    public void testSerializeDeserializeRoutine() throws Exception {
        String env = "DEV";
        String schema = "AAA";
        InMemoryTestDBModelFS dbModelFS = this.createNewDBModelFS();
        SqlNormalizer sqlNormalizer = SqlNormalizer.getInstance(this.repository);

        RoutineSerializer serializer = new RoutineSerializer(this.repository, dbModelFS, schema, env);

        List<Routine> sourceRoutines = new ArrayList<>();
        sourceRoutines.add(this.createFunction(schema, "Function_ZZ", 1));

        when(this.repository.loadRoutineDefinition(schema)).thenReturn(this.extractRoutineDefinitionOnly(sourceRoutines));
        when(this.repository.loadRoutineParameters(schema)).thenReturn(this.extractRoutinesParameters(sourceRoutines));

        serializer.serialize();

        Routine sourceRoutine = sourceRoutines.get(0);
        InMemoryTestDBModelFS.SerializationInfo serializationInfo = dbModelFS.getSerializationInfo(sourceRoutine);


        sourceRoutine.setRoutineDefinition(sqlNormalizer.formatSql(sourceRoutine.getRoutineDefinition()));
        assertEquals(sourceRoutine, serializationInfo.getDBObject());

        Routine deserializedRoutine = textSerializer.fromYAMLtoPOJO(serializationInfo.getYamlText(), Routine.class);

        assertEquals(sourceRoutine, deserializedRoutine);
    }


    /**
     * From a a list of routines extract only the routine basic properties without the routine parameters
     * @param sourceRoutines
     * @return
     * @throws CloneNotSupportedException
     */
    private List<Routine> extractRoutineDefinitionOnly(List<Routine> sourceRoutines) throws CloneNotSupportedException {
        List<Routine> routinesDefs = new ArrayList<>();

        for(Routine original : sourceRoutines){
            Routine copy = new Routine(original.getSchema(), original.getName(), original.getRoutineType());
            copy.setReturnParamater(original.getReturnParamater());
            copy.setRoutineDefinition(original.getRoutineDefinition());

            routinesDefs.add(copy);
        }

        Collections.shuffle(routinesDefs);

        return routinesDefs;
    }

    /**
     * Extract only the routine parameters from a list of routines.
     * All parameters are shuffled before return to allow the serializer order it
     * @param sourceRoutines
     * @return
     */
    private List<RoutineParameter> extractRoutinesParameters(List<Routine> sourceRoutines) {
        List<RoutineParameter> parameters = new ArrayList<>();

        for(Routine sourceRoutine: sourceRoutines){
            parameters.addAll(sourceRoutine.getParameters());
        }
        Collections.shuffle(parameters);

        return parameters;
    }

    private Routine createProcedure(String schema, String routineName, int id) {
        Routine routine = new Routine(schema, routineName + "_" + id, RoutineType.PROCEDURE);
        routine.addParameter(this.createRoutineParameter(schema, routine.getName(),"DummyParam01", 1, "VARCHAR2", ParameterMode.IN));
        routine.addParameter(this.createRoutineParameter(schema, routine.getName(),"DummyParam02", 2, "NUMBER", ParameterMode.IN));
        routine.addParameter(this.createRoutineParameter(schema, routine.getName(),"DummyParam03", 3, "NUMBER", ParameterMode.OUT));

        routine.setRoutineDefinition("BEGIN   /* declare local variables */   DECLARE a INT DEFAULT 10;   DECLARE b, c INT;    /* using the local variables */   SET a = a + 100;   SET b = 2;   SET c = a + b;    BEGIN      /* local variable in nested block */      DECLARE c INT;             SET c = 5;       /* local variable c takes precedence over the one of the          same name declared in the enclosing block. */       SELECT a, b, c;   END;    SELECT a, b, c;");

        return routine;
    }

    private Routine createFunction(String schema, String routineName, int id) {
        Routine routine = new Routine(schema, routineName + "_" + id, RoutineType.FUNCTION);
        routine.setReturnParamater(new TypedColumn(OracleRepository.RETURN_PARAMETER_NAME, 0, "VARCHAR2"));
        routine.addParameter(this.createRoutineParameter(schema, routine.getName(),"Param01", 1, "NUMBER", ParameterMode.IN));
        routine.addParameter(this.createRoutineParameter(schema, routine.getName(),"Param02", 2, "DATETIME", ParameterMode.IN));

        routine.setRoutineDefinition("CREATE OR REPLACE FUNCTION totalRecords ()RETURNS integer AS $total$declaretotal integer;BEGIN   SELECT count(*) into total FROM COMPANY;   RETURN total;END;$total$ LANGUAGE plpgsql;");


        return routine;
    }

    private RoutineParameter createRoutineParameter(String schema, String routineName, String paramName, int ordinalPosition
          , String dataType ,ParameterMode parameterMode){
        RoutineParameter parameter = new RoutineParameter(paramName, ordinalPosition, dataType, parameterMode );
        parameter.setRoutineSchema(schema);
        parameter.setRoutineName(routineName);

        return parameter;
    }

}