package br.lassal.dbvcs.tatubola.relationaldb.serializer;

import br.lassal.dbvcs.tatubola.fs.InMemoryTestDBModelFS;
import br.lassal.dbvcs.tatubola.relationaldb.model.Table;
import br.lassal.dbvcs.tatubola.relationaldb.model.TableColumn;
import br.lassal.dbvcs.tatubola.relationaldb.model.View;
import br.lassal.dbvcs.tatubola.text.SqlNormalizer;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ViewSerializerTest extends BaseSerializerTest{

    /**
     * Test if the ViewSerializer is able to
     *  - assemble tables from separated parts: table columns + constraints
     *  - tidy up the fields and sort them in the proper order
     *  - serialize its content to DBModelFS
     *
     * @throws Exception
     */
    @Test
    public void testViewSerialization() throws Exception {
        String env = "DEV";
        String schema = "AAA";
        InMemoryTestDBModelFS dbModelFS = this.createNewDBModelFS();
        SqlNormalizer sqlNormalizer = SqlNormalizer.getInstance(this.repository);

        ViewSerializer serializer = new ViewSerializer(this.repository, dbModelFS, schema, env);

        List<View> sourceViews = new ArrayList<>();
        sourceViews.add(this.createView(schema, "VIEW001", 1));
        sourceViews.add(this.createView(schema, "VIEW002", 2));
        sourceViews.add(this.createView(schema, "VIEW003", 3));
        sourceViews.add(this.createView(schema, "VIEW004", 4));

        when(this.repository.loadViewDefinitions(schema)).thenReturn(this.extractViewDefinitionsOnly(sourceViews));
        when(this.repository.loadViewColumns(schema)).thenReturn(this.extractViewColumnsOnly(sourceViews));
        when(this.repository.loadViewTables(schema)).thenReturn(this.extractReferencedViewTablesOnly(sourceViews));

        serializer.serialize();

        for(View originalView: sourceViews){
            InMemoryTestDBModelFS.SerializationInfo serializationInfo = dbModelFS.getSerializationInfo(originalView);

            //organize the same formatting for the source definition before check equality
            originalView.setViewDefinition(sqlNormalizer.formatSql(originalView.getViewDefinition()));

            assertEquals(originalView, serializationInfo.getDBObject());
        }

        verify(this.repository, times(1)).loadViewDefinitions(schema);
        verify(this.repository, times(1)).loadViewColumns(schema);
        verify(this.repository, times(1)).loadViewTables(schema);

        assertEquals(sourceViews.size(), dbModelFS.getNumberSerializedObjects());
    }

    /**
     * Test if the output generated by the RoutineSerializer can be deserialized and it
     * has the same properties than the serialized version
     *
     * @throws Exception
     */
    @Test
    public void testSerializeDeserializeView() throws Exception {
        String env = "DEV";
        String schema = "AAA";
        InMemoryTestDBModelFS dbModelFS = this.createNewDBModelFS();
        SqlNormalizer sqlNormalizer = SqlNormalizer.getInstance(this.repository);

        ViewSerializer serializer = new ViewSerializer(this.repository, dbModelFS, schema, env);

        List<View> sourceViews = new ArrayList<>();
        sourceViews.add(this.createView(schema, "VIEW001", 1));

        when(this.repository.loadViewDefinitions(schema)).thenReturn(this.extractViewDefinitionsOnly(sourceViews));
        when(this.repository.loadViewColumns(schema)).thenReturn(this.extractViewColumnsOnly(sourceViews));
        when(this.repository.loadViewTables(schema)).thenReturn(this.extractReferencedViewTablesOnly(sourceViews));

        serializer.serialize();

        View sourceView = sourceViews.get(0);
        InMemoryTestDBModelFS.SerializationInfo serializationInfo = dbModelFS.getSerializationInfo(sourceView);

        sourceView.setViewDefinition(sqlNormalizer.formatSql(sourceView.getViewDefinition()));
        assertEquals(sourceView, serializationInfo.getDBObject());

        View deserializedView = textSerializer.fromYAMLtoPOJO(serializationInfo.getYamlText(), View.class);

        assertEquals(sourceView, deserializedView);

    }

    private List<View> extractViewDefinitionsOnly(List<View> sourceViews){
        List<View> viewDefinitions = new ArrayList<>();

        for(View original: sourceViews){
            View copy = new View(original.getSchema(), original.getName());
            copy.setInsertAllowed(original.isInsertAllowed());
            copy.setUpdatedAllowed(original.isUpdatedAllowed());
            copy.setViewDefinition(original.getViewDefinition());

            viewDefinitions.add(copy);
        }

        Collections.shuffle(viewDefinitions);

        return viewDefinitions;
    }

    private Map<String, List<TableColumn>> extractViewColumnsOnly(List<View> sourceViews){
        Map<String, List<TableColumn>> columns = new HashMap<>();

        for(View sourceView: sourceViews){
            List<TableColumn> tabCols = new ArrayList<>(sourceView.getColumns());
            Collections.shuffle(tabCols);

            columns.put(sourceView.getViewID(), tabCols);
        }

        return columns;
    }

    private Map<String, List<Table>> extractReferencedViewTablesOnly(List<View> sourceViews){
        Map<String, List<Table>> refTables = new HashMap<>();

        for(View sourceView: sourceViews){
            List<Table> tables = new ArrayList<>(sourceView.getReferencedTables());
            Collections.shuffle(tables);

            refTables.put(sourceView.getViewID(), tables);
        }

        return refTables;
    }

    private View createView(String schema, String viewName, int id){
        View view = new View(schema, viewName);
        view.setUpdatedAllowed(true);
        view.setInsertAllowed(false);
        view.setViewDefinition("CREATE OR REPLACE FUNCTION totalRecords ()RETURNS integer AS $total$declaretotal integer;BEGIN   SELECT count(*) into total FROM COMPANY;   RETURN total;END;$total$ LANGUAGE plpgsql;");
        view.addTable(schema, "TableRef01_" + id);
        view.addTable(schema, "TableRef02");

        view.addColumn(this.createTextColumn(1, 50, false));
        view.addColumn(this.createTextColumn(2, 30, false));
        view.addColumn(this.createNumericColumn(3, 20, 6, false));
        view.addColumn(this.createNumericColumn(4, 15, 3, true));

        return view;
    }

    private TableColumn createTextColumn(int orderId, long maxLength, boolean isNullable){
        TableColumn column = this.createTableColumn(orderId, "VARCHAR", isNullable);
        column.setTextMaxLength(maxLength);
        column.setDefaultValue("---<DEFAULT>---");

        return column;
    }

    private TableColumn createNumericColumn(int orderId, int numericPrecison, int numericScale, boolean isNullable){
        TableColumn column = this.createTableColumn(orderId, "NUMBER", isNullable);
        column.setNumericPrecision(numericPrecison);
        column.setNumericScale(numericScale);

        return column;
    }

    private TableColumn createTableColumn(int orderId, String datatype, boolean isNullable){
        TableColumn column = new TableColumn(String.format("COLUMN%02d", orderId));
        column.setOrdinalPosition(orderId);
        column.setDataType(datatype);
        column.setNullable(isNullable);

        return column;
    }

}