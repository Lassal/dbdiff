package br.lassal.dbvcs.tatubola.relationaldb.serializer;

import br.lassal.dbvcs.tatubola.fs.InMemoryTestDBModelFS;
import br.lassal.dbvcs.tatubola.relationaldb.model.*;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.*;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class TableSerializerTest extends BaseSerializerTest{

    /**
     * Test if the TableSerializer is able to
     *  - assemble tables from separated parts: table columns + constraints
     *  - tidy up the fields and sort them in the proper order
     *  - serialize its content to DBModelFS
     *
     * @throws Exception
     */
    @Test
    public void testTableSerialization() throws Exception {
        String env = "DEV";
        String schema = "AAA";
        InMemoryTestDBModelFS dbModelFS = this.createNewDBModelFS();
        TableDummyBuilder tableBuilder = new TableDummyBuilder();

        TableSerializer serializer = new TableSerializer(this.repository, dbModelFS, schema, env);

        List<Table> sourceTables = new ArrayList<>();
        sourceTables.add(tableBuilder.createFullTable(schema, "TABLE001", 1));
        sourceTables.add(tableBuilder.createFullTable(schema, "TABLE002", 2));
        sourceTables.add(tableBuilder.createFullTable(schema, "TABLE003", 3));
        sourceTables.add(tableBuilder.createFullTable(schema, "TABLE004", 4));
        sourceTables.add(tableBuilder.createFullTable(schema, "TABLE005", 5));


        when(this.repository.loadTableColumns(schema)).thenReturn(this.extractTableColumnsOnly(sourceTables));
        when(this.repository.loadCheckConstraints(schema)).thenReturn(this.extractCheckConstraints(sourceTables));
        when(this.repository.loadUniqueConstraints(schema)).thenReturn(this.extractUniqueConstraints(sourceTables));
        when(this.repository.loadReferentialConstraints(schema)).thenReturn(this.extractFKConstraints(sourceTables));

        serializer.serialize();

        for(Table originalTable: sourceTables){
            InMemoryTestDBModelFS.SerializationInfo serializationInfo = dbModelFS.getSerializationInfo(originalTable);

            assertEquals(originalTable, serializationInfo.getDBObject());
        }

        verify(this.repository, times(1)).loadTableColumns(schema);
        verify(this.repository, times(1)).loadCheckConstraints(schema);
        verify(this.repository, times(1)).loadUniqueConstraints(schema);
        verify(this.repository, times(1)).loadReferentialConstraints(schema);

        assertEquals(sourceTables.size(), dbModelFS.getNumberSerializedObjects());
    }

    /**
     * Test if the output generated by the TableSerializer can be deserialized and it
     * has the same properties than the serialized version
     * @throws Exception
     */
    @Test
    public void testSerializeDeserializeTable() throws Exception {
        String env = "DEV";
        String schema = "XPTO";
        InMemoryTestDBModelFS dbModelFS = this.createNewDBModelFS();
        TableSerializer serializer = new TableSerializer(this.repository, dbModelFS, schema, env);
        TableDummyBuilder tableBuilder = new TableDummyBuilder();

        List<Table> sourceTables = new ArrayList<>();
        sourceTables.add(tableBuilder.createFullTable(schema, "TABLE001", 1));

        when(this.repository.loadTableColumns(schema)).thenReturn(this.extractTableColumnsOnly(sourceTables));
        when(this.repository.loadCheckConstraints(schema)).thenReturn(this.extractCheckConstraints(sourceTables));
        when(this.repository.loadUniqueConstraints(schema)).thenReturn(this.extractUniqueConstraints(sourceTables));
        when(this.repository.loadReferentialConstraints(schema)).thenReturn(this.extractFKConstraints(sourceTables));

        serializer.serialize();

        Table sourceTable = sourceTables.get(0);
        InMemoryTestDBModelFS.SerializationInfo serializedTableInfo = dbModelFS.getSerializationInfo(sourceTable);

        assertEquals(sourceTable, serializedTableInfo.getDBObject());

        Table deserializedTable = this.textSerializer.fromYAMLtoPOJO(serializedTableInfo.getYamlText(), Table.class);

        assertEquals(sourceTable, deserializedTable);

    }


    /**
     * Disassemble each table creating a copy of the table with only the columns.
     * Shuffles all columns to create a situation where they were load from the
     * database unordered
     * This method return the tables in the same format expected by
     * RelationalDBRepository.loadTableColumns
     *
     * @param sourceTables A list of fully filled tables
     * @return a Map with Key Schema.TableName, and value Table instance
     */
    private Map<String, Table> extractTableColumnsOnly(List<Table> sourceTables)  {
        Map<String, Table> tableColumns = new HashMap<>();

        for(Table table: sourceTables){
           Table copy = new Table(table.getSchema(), table.getName());
           List<TableColumn> columns = new ArrayList<>(table.getColumns());
           Collections.shuffle(columns);
           columns.stream().forEach(c -> copy.addColumn(c));

           tableColumns.put(copy.getTableID(), copy);
        }

        return tableColumns;
    }

    /**
     * Extract a list of Unique constraints from a list of expected tables
     * For each UniqueConstraint in the table list create a copy and shuffle the column order
     * to test how the assembler will order it
     *
     * It returns a list in the format defined at RelationalDBRepository.loadUniqueConstraints
     * @param sourceTables A list of fully filled tables
     * @return A list of unique constraints found in the provided list
     * @throws CloneNotSupportedException
     */
    private List<TableConstraint> extractUniqueConstraints(List<Table> sourceTables) throws CloneNotSupportedException {
        List<TableConstraint> constraints = new ArrayList<>();

        for(Table table: sourceTables){
            for(TableConstraint tc : table.getConstraints()){
                if(tc instanceof UniqueConstraint){
                    UniqueConstraint original = (UniqueConstraint) tc;
                    UniqueConstraint copy = (UniqueConstraint) original.clone();
                    List<Column> columns = new ArrayList<>(original.getColumns());
                    Collections.shuffle(columns);
                    copy.setColumns(columns);

                    constraints.add(copy);
                }
            }
        }

        Collections.shuffle(constraints);

        return constraints;
    }


    /**
     * Extract a list of referential constraints from a list of expected tables
     * For each ForeignKeyConstraint in the table list create a copy and shuffle the column order
     * to test how the assembler will order it
     *
     * It returns a list in the format defined at RelationalDBRepository.loadReferentialConstraints
     * @param sourceTables A list of fully filled tables
     * @return A list of referential constraints found in the provided list
     * @throws CloneNotSupportedException
     */
    private List<TableConstraint> extractFKConstraints(List<Table> sourceTables) throws CloneNotSupportedException {
        List<TableConstraint> constraints = new ArrayList<>();

        for(Table table: sourceTables){
            for(TableConstraint tc : table.getConstraints()){
                if(tc instanceof ForeignKeyConstraint){
                    ForeignKeyConstraint original = (ForeignKeyConstraint) tc;
                    ForeignKeyConstraint copy = (ForeignKeyConstraint) original.clone();
                    List<ReferentialIntegrityColumn> columns = new ArrayList<>(original.getColumns());
                    Collections.shuffle(columns);
                    copy.setColumns(columns);

                    constraints.add(copy);
                }
            }
        }

        Collections.shuffle(constraints);

        return constraints;
    }

    /**
     * Extract a list of check constraints from a list of expected tables
     * For each CheckConstraint in the table list create a copy of it
     *
     * It returns a list in the format defined at RelationalDBRepository.loadCheckConstraints
     * @param sourceTables A list of fully filled tables
     * @return A list of check constraints found in the provided list
     * @throws CloneNotSupportedException
     */
    private List<TableConstraint> extractCheckConstraints(List<Table> sourceTables) throws CloneNotSupportedException {
        List<TableConstraint> constraints = new ArrayList<>();

        for(Table table: sourceTables){
            for(TableConstraint tc : table.getConstraints()){
                if(tc instanceof CheckConstraint){
                    CheckConstraint original = (CheckConstraint) tc;
                    CheckConstraint copy = (CheckConstraint) original.clone();
                    constraints.add(copy);
                }
            }
        }

        Collections.shuffle(constraints);

        return constraints;
    }



}